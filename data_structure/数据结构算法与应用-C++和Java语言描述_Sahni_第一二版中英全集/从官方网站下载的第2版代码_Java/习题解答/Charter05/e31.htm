<HTML>
<HEAD>
<LINK rel="stylesheet" href="../exer.css">
</HEAD>
<BODY>
<H1>
Data Structures, Algorithms, & Applications in Java<BR>
Chapter 5, Exercise 31<BR>
<BR>
</H1>
<DL Compact>
<DT> (a)
<DD>
The merge can be done by examining the elements of the two input
lists <code class=code>a</code> and
<code class=code>b</code> from the first element to the last.
The smaller element is copied into
the result list.
The member method is given below.
The variables
<code class=code>ca</code> and
<code class=code>cb</code> act as cursors that move through
the lists
<code class=code>a</code> and
<code class=code>b</code> from the first element to the last.
<code class=code>ct</code> is a
cursor that keeps track of the location for the
next element of the result.
</dl>
<HR class = coderule>
<PRE class = code>
public class ArrayCircularListWithMerge
       extends ArrayCircularList
{
   /** make this the result of merging the sorted lists a and b */
   public void merge(ArrayCircularListWithMerge a,
                     ArrayCircularListWithMerge b)
   {
      int ca = a.first;                 // cursor for a
      int cb = b.first;                 // cursor for b
      int ct = 0;                       // cursor for this
      int na = 0;                       // number merged from a
      int nb = 0;                       // number merged from b
      int as = a.size();                // size of a
      int bs = b.size();                // size of b
      // get big enough array for result
      // if you opt to do this only when as + bs > element.length,
      // be sure to set relevant positions of element to null
      // to enable garbage collection
      element = new Object [as + bs];

      // merge from a and b
      while ((na &lt; as) &amp;&amp; (nb &lt; bs))
         if (((Comparable) a.element[ca]).compareTo(b.element[cb]) &lt;= 0)
         {// merge from a
            element[ct++] = a.element[ca];
            ca = (ca + 1) % a.element.length;
            na++;
         }
         else
         {// merge from b
            element[ct++] = b.element[cb];
            cb = (cb + 1) % b.element.length;
            nb++;
         }
   
      // take care of left overs
      if (na == a.size())                 // a is finished
         for (int q = nb; q &lt; bs; q++)
         {
            element[ct++] = b.element[cb];
            cb = (cb + 1) % b.element.length;
         }
      else  // b is finished
         for (int q = na; q &lt; as; q++)
         {
            element[ct++] = a.element[ca];
            ca = (ca + 1) % a.element.length;
         }
      first = 0;
      last = ct - 1;
   }
}
</pre>
<HR class=coderule><BR>
<dl compact>
<dt> (b)
<dd>
In each iteration of the <code class=code>while</code> loop the value
of <code class=code>ct</code> increases
by one.  On exiting this loop, <code class=code>ct &lt;</code>
<code class=code>a.size + b.size</code>.
The time spent in the <code class=code>for</code> loops is
either <code class=code>O(a.size)</code>
or <code class=code>O(b.size)</code>.
So, the complexity is <code class=code>O(a.size + b.size)</code>.
<dt> (c)
<dd>
The test program is given as the method
<code class=code>dataStructures.ArrayCircularList.main</code>.
The output is in the file
<code class=code>ArrayCircularList.output</code>.
</dl>

</FONT>
</BODY>
</HTML>
