
<HTML>
<HEAD>
<LINK rel="stylesheet" href="../exer.css">
</HEAD>
<BODY>
<H1>
Data Structures, Algorithms, & Applications in Java<BR>
Chapter 18, Exercise 33<BR>
<BR>
</H1>

To find the shortest path from the source vertex <code class=code>s</code>
to the vertex <code class=code>i</code>, we first verify the existence
of such a path.  A path exists iff <code class=var>p[i] != 0</code>.
When the path exists, it may be constructed backwards from
<code class=code>i</code> to <code class=var>s</code> by
following the vertex sequence <code class=var>p[i]</code>,
<code class=var>p[p[i]]</code>,
<code class=var>p[p[p[i]]]</code>, ...,
<code class=var>s</code>.

<br><br>


The nethod <code class=code>AdjacencyWDigraph.path</code>, which is
given below,
outputs the path backwards.
If we must output the forward path, we can first store the
backward path in an array and then output it in the desired order.
A test program, input, and output appear in the files
<code class=code>TestPath.*</code>.

<HR class = coderule>
<pre class = code>
/** output shortest path from vertex s to vertex i
  * @param p p[i] is predecessor of vertex i on shortest path */
public static void path(int [] p, int s, int i)
{
   if (p[i] == -1)
   {// no path from s to i
      System.out.println("There is no path from vertex "
           + s + " to vertex " + i);
      return;
   }

   // there is a shortest path to i
   // construct it backwards from i to s
   System.out.print("Shortest path from vertex "
        + s + " to vertex " + i + " is the reverse of " + i);
   while (i != s)
   {// move back one vertex
      i = p[i];
      System.out.print(" " + i);
   }
   System.out.println();
}
<hr class=coderule>
</pre>
<br><br>

Since a shortest path has at most <code class=code>n</code>
vertices on it, the complexity of <code class=var>path</code>
is <code class=code>O(n)</code>.

</FONT>
</BODY>
</HTML>
