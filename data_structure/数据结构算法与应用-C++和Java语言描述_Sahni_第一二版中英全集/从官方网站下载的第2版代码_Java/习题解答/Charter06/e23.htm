<HTML>
<HEAD>
<LINK rel="stylesheet" href="../exer.css">
</HEAD>
<BODY>
<H1>
Data Structures, Algorithms, & Applications in Java<BR>
Chapter 6, Exercise 23<BR>
<BR>
</H1>
<br><br>
<font color=blue>BUBBLE SORT</font><br>
The bubble sort code mimics the array-based code of Program 2.9.
It may be modified to obtain an early-terminating version.
The code is given below and in the file
<code class=code>ChainWithSortMethods.java</code>.
</dl>
<HR class = coderule>
<PRE class = code>
/** bubble largest element in first n nodes to right */
private void bubble(int n)
{
   ChainNode currentNode = firstNode;
   for (int i = 0; i &lt; n - 1; i++)
   {
      ChainNode nextNode = currentNode.next;
      if (((Comparable) currentNode.element)
            .compareTo(nextNode.element) &gt; 0)
      {// swap elements
         Object temp = currentNode.element;
         currentNode.element = nextNode.element;
         nextNode.element = temp;
      }
      currentNode = nextNode;
   }
}

/** sort the array a using the bubble sort method */
public void bubbleSort()
{
   for (int i = size; i &gt; 1; i--)
      bubble(i);
}
<HR class = coderule>
</pre>
<br>

Each bubbling pass takes
<code class=math>Theta(i)</code> time, where <code class=math>i</code>
is the number of nodes on the
portion of the chain that is yet to be sorted.
For an <code class=math>n</code>
node input chain, the time needed is
<code class=math>Theta(n<sup>2</sup>)</code>.
This is the asymptotic complexity for all data including
initially sorted lists.
There is some variability in the actual
run time because the number
of element swaps made in each bubbling pass varies.
<br>
<br>

<font color=blue>SELECTION SORT</font><br>
The code is very similar to Program 2.7.  It is given below and
in the file <code class=code>ChainWithSortMethods.java</code>.
<HR class = coderule>
<PRE class = code>
/** sort the chain using the selection sort method */
public void selectionSort()
{
   for (int i = size; i &gt; 1; i--)
   {
      // find max object from first i nodes
      Comparable currentMax = (Comparable) firstNode.element;
      ChainNode maxNode = firstNode;
      ChainNode currentNode = firstNode;
      for (int j = 1; j &lt; i; j++)
      {
         ChainNode nextNode = currentNode.next;
         if (currentMax.compareTo(nextNode.element) &lt; 0)
         {// found a larger element
            currentMax = (Comparable) nextNode.element;
            maxNode = nextNode;
         }

         // move to next node
         currentNode = nextNode;
      }

      // move max object to right end
      maxNode.element = currentNode.element;
      currentNode.element = currentMax;
   }
}
<HR class = coderule>
</pre>
<br>
Each selection pass takes
<code class=math>Theta(i)</code> time, where <code class=math>i</code> is
the number of nodes on the
portion of the chain that is not known to be sorted.
For an <code class=math>n</code>
node input chain, the time needed is
<code class=math>Theta(n<sup>2</sup>)</code>.
<br><br>
<font color=blue>RANK SORT</font><br>
The code to compute the ranks is
very similar to Program 2.5.  The actual
rearrangement is done by assigning the elements to bins
according to their rank and then collecting the elements
from the bins in rank order. The code is given below and
in the file <code class=code>ChainWithSortMethods.java</code>.
</dl>
<HR class = coderule>
<PRE class = code>
/** sort the chain using the rank sort method */
public void rankSort()
{
   if (size == 0)
      return;  // empty chain

   // r[i] will be rank of element i
   int [] r = new int [size];

   // compute ranks by comparing all pairs of elements
   ChainNode currentNode = firstNode;
   for (int i = 0; i &lt; size; i++)
   {// compare currentNode.element with all elements
      ChainNode node = firstNode;
      for (int j = 0; j &lt; i; j++)
      {// currentNode.element is element i and node.element
       // is element j, j &lt; i
         if (((Comparable) node.element).compareTo
                                (currentNode.element) <= 0)
            r[i]++;
         else
            r[j]++;
         node = node.next;
      }
      currentNode = currentNode.next;
   }

   // distribute nodes to bins by rank
   ChainNode [] bin = new ChainNode [size];
   currentNode = firstNode;
   for (int i = 0; i &lt; size; i++)
   {
      bin[r[i]] = currentNode;
      currentNode = currentNode.next;
   }

   // collect from bins
   firstNode = bin[0];
   ChainNode lastNode = firstNode;  // last node on chain
   for (int i = 1; i &lt; size; i++)
      lastNode = lastNode.next = bin[i];
   lastNode.next = null;
}
<HR class = coderule>
</pre>
<br>
For an <code class=math>n</code>
node input chain, the time taken to rank the elements is
<code class=math>Theta(n<sup>2</sup>)</code>.
The ensuing assignment and collection from bins takes
<code class=math>Theta(n)</code> time.
Therefore, if an exception is not thrown, the complexity is
<code class=math>Theta(n<sup>2</sup>)</code>.


</FONT>
</BODY>
</HTML>
