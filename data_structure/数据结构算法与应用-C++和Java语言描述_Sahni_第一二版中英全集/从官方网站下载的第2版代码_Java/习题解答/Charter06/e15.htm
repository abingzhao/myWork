
<HTML>
<HEAD>
<LINK rel="stylesheet" href="../exer.css">
</HEAD>
<BODY>
<H1>
Data Structures, Algorithms, & Applications in Java<BR>
Chapter 6, Exercise 15<BR>
<BR>
</H1>
<dl compact>
<dt> (a)
<dd>
The merge method uses chain iterators to move through the
input lists <code class=code>a</code> and
<code class=code>b</code>.  At any time in the
first <code class=code>while</code> loop below,
<code class=code>elementA</code> is
the first unused element
of list
<code class=code>a</code>, and
<code class=code>elementB</code> is
the first unused element
of list
<code class=code>b</code>.
The smaller of these is appended
to the output list.  If the appended
element came from <code class=code>a</code>, we move to the next element of
list <code class=code>a</code>. Otherwise,
we move to the next element of <code class=code>b</code>.
<HR class = coderule>
<PRE class = code>
public class MergeExtendedChain
{
   /** merge the sorted chains a and b */
   public static ExtendedChain merge(ExtendedChain a, ExtendedChain b)
   {
      // initialize iterators for a and b
      Iterator ia = a.iterator();     // iterator for a
      Iterator ib = b.iterator();     // iterator for b
      Comparable elementA = null;     // current element of a
      if (ia.hasNext())
         elementA = (Comparable) ia.next();
      Object elementB = null;         // current element of b
      if (ib.hasNext())
         elementB = ib.next();
   
      // create result chain
      ExtendedChain c = new ExtendedChain();
   
      // do the merge
      while (elementA != null &amp;&amp; elementB != null)
      {
         if (elementA.compareTo(elementB) &lt;= 0)
         {// elementA goes next
            c.add(elementA);
            if (ia.hasNext())
               elementA = (Comparable) ia.next();
            else
               elementA = null;
         }
         else
         {// elementB goes next
            c.add(elementB);
            if (ib.hasNext())
               elementB = ib.next();
            else
               elementB = null;
         }
      }
   
      // add remaining elements
      if (elementA != null)
         c.add(elementA);
      if (elementB != null)
         c.add(elementB);

      // at most one of a and b can be nonempty now
      while (ia.hasNext())
         c.add(ia.next());
   
      while (ib.hasNext())
         c.add(ib.next());
   
      return c;
   }
}
</pre>
<HR class=coderule><BR><br>
<dt> (b)
<dd>
In each iteration of the first <code class=code>while</code> loop, we
move one node right in
either <code class=code>a</code> or
<code class=code>b</code>.
So, the complexity of this loop is
<code class=math>O(a.size + b.size)</code>.
The complexity of the second <code class=code>while</code> loop
is <code class=math>O(a.size)</code>, and that of the third
loop is <code class=math>O(b.size)</code>.
So, the overall complexity is
<code class=math>O(a.size + b.size)</code>.
<br><br>
<dt> (c)
<dd>
The codes and output are in the files <code class=code>MergeExtendedChain.*</code>.

</dl>

</FONT>
</BODY>
</HTML>
