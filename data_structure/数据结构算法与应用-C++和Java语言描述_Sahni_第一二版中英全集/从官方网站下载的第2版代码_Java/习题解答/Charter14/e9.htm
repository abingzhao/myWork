
<HTML>
<HEAD>
<LINK rel="stylesheet" href="../exer.css">
</HEAD>
<BODY>
<H1>
Data Structures, Algorithms, & Applications in Java<BR>
Chapter 14, Exercise 9<BR>
<BR>
</H1>
<dl compact>
<dt> (a)
<dd>
The size of the array
<code class=code>tree[]</code> is <code class=var>m</code> where
<code class=var>m</code> is the smallest integer <code class=var>&gt;= n</code>
that is a power of <code class=var>2</code>.  It may be shown that
<code class=var>n &lt;= m &lt; 2n - 1</code>.  Therefore, the additional space
is for at most <code class=var>n - 1</code> positions of <code class=code>tree</code>.

<dt> (b)
<dd>
The new implementation is given below.  The data member
<code class=code>offset</code> equals <code class=code>m-1</code>.
Since the players and internal nodes
are in different arrays, it is still necessary to play
lowest-level matches separately from the remaining matches.
<HR class = coderule>
<pre class = code>
public class FullWinnerTree implements WinnerTree
{
   // data members
   int offset;           // 2^ceil(log n) - 1
   int [] tree;          // array for winner tree
   Playable [] player;   // array of players

   // only default constructor available

   /** @return the winner of the tournament
     * @return 0 if there are no players */
   public int getWinner()
      {return (tree == null) ? 0 : tree[1];}

   /** initialize winner tree for thePlayer[1:thePlayer.length-1] */
   public void initialize(Playable [] thePlayer)
   {
      int n = thePlayer.length - 1;
      if (n &lt; 2)
         throw new IllegalArgumentException
                   ("must have at least 2 players");

      // compute  smallest m &gt;= n and a power of 2
      int m;
      for (m = 1; m &lt; n; m += m);
   
      // set instance data members
      player = thePlayer;
      tree = new int [m];
      offset = m - 1;
   
      int p = (n + offset) / 2;  // tree[p] is largest p where a match is played

      // play match at tree[p]
      if (n % 2 == 1)
         // n is odd, tree[p] has only one child
          tree[p] = n;
      else
         // n is even, tree[p] has two children
         tree[p] = player[n - 1].winnerOf(player[n]) ? n - 1 : n;

      // play remaining matches at lowest level
      int lp = 1;  // player[lp] is left child player
      for (int i = m / 2; i &lt; p; i++)
      {
         tree[i] = player[lp].winnerOf(player[lp + 1]) ? lp : lp + 1;
         lp += 2;
      }

      // play matches at remaining levels
      for (int i = p / 2; i &gt;= 1; i--)
      {
          int lc = 2 * i;  // index of left child of node i
          if (tree[lc + 1] == 0)
             // no right child
             tree[i] = tree[lc];
          else
             tree[i] = player[tree[lc]].winnerOf(player[tree[lc + 1]]) ?
                                        tree[lc] : tree[lc + 1];
      }
   }
   
   
   /** replay matches for player i */
   public void rePlay(int i)
   {
      int n = player.length - 1;  // number of players
      if (i &lt;= 0 || i &gt; n)
         throw new IllegalArgumentException("No player " + i);
   
      // play first match
      int p = (i + offset) / 2;  // node for first match
      if (2 * p + 1 &gt; n)
         // only player for this match
         tree[p] = i;
      else
      {// two players
         int lp = 2 * p - offset;   // left player
         tree[p] = player[lp].winnerOf(player[lp + 1]) ? lp : lp + 1;
      }

      // play remaining matches
      p /= 2;  // move to parent
      for (; p &gt;= 1; p /= 2)
         if (tree[2 * p + 1] == 0)
            // only one player
            tree[p] = tree[2 * p];
         else
            // two players
            tree[p] = player[tree[2 * p]].winnerOf(
                      player[tree[2 * p + 1]]) ? tree[2 * p] : tree[2 * p + 1];
   }
}
<hr class=coderule>
</pre>
<br><br>

<dt> (c)
<dd>
A test program, input and output appear in the files
<code class=code>FullWinnerTree.*</code>.
<br><br>
<dt> (d)
<dd>
Although the asymptotic complexity of both implementations is the same,
we expect the implementation of this exercise to take more time
than taken by the implementation of the text because most of the
matches played in the implementation of this exercise require us
to determine whether or not we have a right child player. Such a
determination is not done in the implementation of the text.
</FONT>
</BODY>
</HTML>
