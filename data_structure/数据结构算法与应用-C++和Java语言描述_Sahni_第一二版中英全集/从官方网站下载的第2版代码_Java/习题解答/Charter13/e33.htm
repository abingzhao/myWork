
<HTML>
<HEAD>
<LINK rel="stylesheet" href="../exer.css">
</HEAD>
<BODY>
<H1>
Data Structures, Algorithms, & Applications in Java<BR>
Chapter 13, Exercise 33<BR>
<BR>
</H1>

A <code class=code>changeMin</code> can be done by changing the root element
and then performing a root to leaf scan of the min heap (as in a remove
min) sliding elements up if they are smaller than the new element.
The derived class has all the public member
methods of <code class=code>MinHeap</code>
plus the method <code class=code>changeMin</code>. 
The code for the derived class <code class=code>ExtendedMinHeap</code>
is given below.
<br><br>


<HR class = coderule>
<pre class = code>
public class ExtendedMinHeap extends MinHeap
{
   // constructor
   public ExtendedMinHeap(int initialCapacity)
      {super(initialCapacity);}

   public ExtendedMinHeap()
      {super();}

   
   /** replace the current min element by theElement
     * @return original min element */
   public Comparable changeMin(Comparable theElement)
   {
      if (size == 0)
      {// heap is empty, heap capacity is at least 1
         heap[++size] = theElement;
         return null;
      }

      // save min element in e
      Comparable e = heap[1];
   
      // put replacement element into the heap
      int i = 1,                // location of vacancy
          ci = 2;               // ci is child of i
      while (ci &lt;= size)
      {// find place to put theElement
         if (ci &lt; size &amp;&amp; heap[ci].compareTo(heap[ci + 1]) &gt; 0)
            ci++;
         // now ci points to smaller child of i
   
         // can we put theElement in heap[i]?
         if (theElement.compareTo(heap[ci]) &lt;= 0)
            break;              // yes
   
         // no
         heap[i] = heap[ci];    // move child up
    
         // move i and ci one level down
         i = ci;
         ci *= 2;
      }
   
      heap[i] = theElement;
      return e;
   }
}
<hr class=coderule>
</pre>
<br><br>
With the availability of the
<code class=code>changeMin</code>
method, the code for
<code class=code>makeSchedule</code> may be made more efficient.
The new code is given below.  The lines that have changed are
shown in <font color=red>red</code>.  A test program and output
appear in the files
<code class=code>ImprovedLPTSchedule.*</code>.


<HR class = coderule>
<pre class = code>
public static void makeSchedule(JobNode [] a, int m)
{
   if (a.length &lt;= m)
   {
      System.out.println("Schedule each job on a different machine.");
      return;
   }

   HeapSort.heapSort(a); // in ascending order

   // initialize m machines and the min heap
   ExtendedMinHeap machineHeap = new ExtendedMinHeap(m);
   for (int i = 1; i &lt;= m; i++)
   {
      MachineNode x = new MachineNode(i, (Operable) a[1].time.zero());
      machineHeap.put(x);
   }

   // construct schedule
   for (int i = a.length - 1; i &gt;= 1; i--)
   {// schedule job i on first free machine
      <font color=red>MachineNode x = (MachineNode) machineHeap.getMin();</font>
      System.out.println("Schedule job " + a[i].id 
           + " on machine " + x.id + " from " + x.avail
           + " to " + x.avail.add(a[i].time));
      x.avail.increment(a[i].time);  // new available time for this machine
      <font color=red>machineHeap.changeMin(x);</font>
   }
}
<hr class=coderule>
</pre>

</FONT>
</BODY>
</HTML>
