
<HTML>
<HEAD>
<LINK rel="stylesheet" href="../exer.css">
</HEAD>
<BODY>
<H1>
Data Structures, Algorithms, & Applications in Java<BR>
Chapter 15, Exercise 19<BR>
<BR>
</H1>

First we must decide how we are going to incorporate
the field <code class=code>leftSize</code>.
We can either require the user to include this
field as one of the fields of the elements he/she will insert into
the search tree,
or we can define
a new type <code class=code>IndexedElement</code>
with a <code class=code>leftSize</code> field and a
field <code class=code>element</code> of type <code class=code>Object</code>.
In our implementation of <code class=code>IndexedBinarySearchTree</code>
we have gone the second route.
<br><br>
The code for the class <code class=code>IndexedElement</code>
is given below.

<HR class = coderule>
<PRE class = code>
static class IndexedElement
{
   // data members
   Object element;        // element in node
   int leftSize;          // number of nodes in left subtree

   // constructors
   IndexedElement(int theLeftSize, Object theElement)
   {
      leftSize = theLeftSize;
      element = theElement;
   }

   IndexedElement(Object theElement)
      {element = theElement;}

   /** @return equivalent string suitable for output */
   public String toString()
      {return element.toString();}
}
</pre>
<HR class=coderule><BR><br>

The class <code class=code>IndexedBinarySearchTree</code> is derived
from <code class=code>BinarySearchTree</code>.
The method
<code class=code>ascend</code> as well as the constructor
are
simply inherited from the base class.
<br><br>
The code for the method <code class=code>get(theKey)</code> invokes
<code class=code>BinarySearchTree.get(theKey)</code>, which returns
an element of type <code class=code>IndexedElement</code>.
The <code class=code>element</code> field of this returned object
is extracted and returned as the result.  The code is given below.


<HR class = coderule>
<PRE class = code>
/** @return element whose key is theKey
  * @return null if there is no element with key theKey */
public Object get(Object theKey)
{
   Object theElement = super.get(theKey);
   if (theElement == null)
      // no matching element
      return null;
   else
      return ((IndexedElement) theElement).element;
}
</pre>
<HR class=coderule><BR><br>

To facilitate the implementation of the method <code class=code>get(theIndex)</code>,
we first develop the method <code class=code>getDataElement(theIndex)</code>,
which returns the <code class=code>element</code> field (this is of type
<code class=code>Data</code>) of the node whose index is
<code class=code>theIndex</code>.

<HR class = coderule>
<PRE class = code>
/** @return Data object of element whose index is theIndex
  * @return null if there is no element with index theIndex */
Data getDataElement(int theIndex)
{
   BinaryTreeNode p = root;
   while (p != null)
   {
      IndexedElement q = (IndexedElement) ((Data) p.element).element;
      if (theIndex &lt; q.leftSize)
         // desired element is in left subtree
         p = p.leftChild;
      else
         if (theIndex &gt; q.leftSize)
         {// desired element is in left subtree
   	        theIndex -= q.leftSize + 1;
             p = p.rightChild;
         }
         else 
            // found desired element
            return (Data) p.element; 
   }

   // no element with index equal to theIndex
   return null;
}
</pre>
<HR class=coderule><BR><br>
Now, we use the method <code class=code>getDataElement</code> to arrive
at the code for <code class=code>get(theIndex)</code>.

<HR class = coderule>
<PRE class = code>
/** @return element whose index is theIndex
  * @return null if there is no element with index theIndex */
public Object get(int theIndex)
{
   Data theData = getDataElement(theIndex);
   if (theData == null)
      // no element with index theIndex
      return null;
   else
      return ((IndexedElement) theData.element).element;
}
</pre>
<HR class=coderule><BR><br>

An insert may be performed in two phases.  First, an insert is done assuming
we have an ordinary binary search tree (not an indexed one).  If the tree
did not already contain an element with the given key,
then another pass is made from the root to the newly inserted node
adjusting the value of <code class=code>leftSize</code> as needed.
If we use <code class=code>BinarySearchTree.put</code> for the first
pass, we must determine the size of the search tree before and
after the invocation of <code class=code>BinarySearchTree.put</code>
so that we can determine whether or not the second pass is to be made.
An alternative to this is to just replicate the code of
<code class=code>BinarySearchTree.put</code> into
<code class=code>IndexedBinarySearchTree.put</code>.  We take this alternative
route below.


<HR class = coderule>
<PRE class = code>
/** insert an element with the specified key
  * overwrite old element if there is already an
  * element with the given key
  * @return old element (if any) with key = theKey */
public Object put(Object theKey, Object theElement)
{
   BinaryTreeNode p = root,     // search pointer
                  pp = null;    // parent of p
   Comparable elementKey = (Comparable) theKey;
   // find place to insert theElement
   while (p != null)
   {// examine p.element.key
      pp = p;
      // move p to a child
      if (elementKey.compareTo(((Data) p.element).key) &lt; 0)
         p = p.leftChild;
      else if (elementKey.compareTo(((Data) p.element).key) &gt; 0)
              p = p.rightChild;
           else
           {// overwrite element with same key
              Object elementToReturn = ((Data) p.element).element;
              ((Data) p.element).element = theElement;
              return elementToReturn;
           }
   }

   // get a node for theElement and attach to pp
   IndexedElement q = new IndexedElement(0, theElement);
   BinaryTreeNode r = new BinaryTreeNode
                          (new Data(elementKey, q));
   if (root != null)
      // the tree is not empty
      if (elementKey.compareTo(((Data) pp.element).key) &lt; 0)
         pp.leftChild = r;
      else
         pp.rightChild = r;
   else // insertion into empty tree
      root = r;

   // a new element has been inserted , update leftSize
   // by following search path to elementKey
   p = root;
   while (true)
      if (elementKey.compareTo(((Data) p.element).key) &lt; 0)
      {// theElement was inserted in left subtree of p
         ((IndexedElement) ((Data) p.element).element).leftSize++;
         p = p.leftChild;
      }
      else
         if (elementKey.compareTo(((Data) p.element).key) &gt; 0)
            // theElement was inserted in right subtree of p
            p = p.rightChild;
         else
            // reached newly inserted element
            return null;
}
</pre>
<HR class=coderule><BR><br>

<br><br>
An element may be removed using a two step algorithm.  In the first,
a search is made to verify the presence of the desired element.
In the second, <code class=code>leftSize</code> fields are adjusted and the element removed.
The code is given below.


<HR class = coderule>
<pre class = code>
/** @return matching element and remove it
  * @return null if no matching element */
public Object remove(Object theKey)
{
   Object theElement = get(theKey);
   if (theElement == null)
      // no matching element
      return null;

   // there is a matching element, remove it
   theRemove(theKey);

   return theElement;
}
<hr class=coderule>
</pre>
<br><br>

The method <code class=code>theRemove</code> is similar to
<code class=code>BinarySearchTree.remove</code>
except that it knows that the delete will succeed and it also
updates <code class=code>leftSize</code> fields.  The code is given below.


<HR class = coderule>
<pre class = code>
/** remove the element with key equal to theKey
  * such an element is guaranteed to exist in the tree */
void theRemove(Object theKey)
{
   Comparable searchKey = (Comparable) theKey;

   // p will eventually point to node with key searchKey
   BinaryTreeNode p = root,    // search pointer
                  pp = null;   // parent of p

   // follow path to searchKey decrementing leftSize each time
   // we move to a left subtree
   while (!((Data) p.element).key.equals(searchKey))
   {// move to a child of p
      pp = p;
      if (searchKey.compareTo(((Data) p.element).key) < 0)
      {
         ((IndexedElement) ((Data) p.element).element).leftSize--;
         p = p.leftChild;
      }
      else
         p = p.rightChild;
   }

   // restructure tree
   // handle case when p has two children
   if (p.leftChild != null &amp;&amp; p.rightChild != null)
   {// two children
      // convert to zero or one child case
      // find element with largest key in left subtree of p
      int ls = ((IndexedElement) ((Data) p.element).element)
                                   .leftSize - 1; // save value
      BinaryTreeNode s = p.leftChild,
                     ps = p;  // parent of s
      while (s.rightChild != null)
      {// move to larger element
         ps = s;
         s = s.rightChild;
      }

      // move largest element from s to p
      p.element = s.element;
      ((IndexedElement) ((Data) p.element).element).leftSize = ls;
      p = s;
      pp = ps;
   }

   // p has at most one child, save this child in c
   BinaryTreeNode c;
   if (p.leftChild == null)
      c = p.rightChild;
   else
      c = p.leftChild;

   // remove node p
   if (p == root) root = c;
   else
   {// is p left or right child of pp?
      if (p == pp.leftChild)
         pp.leftChild = c;
      else
         pp.rightChild = c;
   }
}
<hr class=coderule>
</pre>
<br><br>


An indexed delete may be done in a similar way.  The code is given below.


<HR class = coderule>
<pre class = code>
/** @return element with index theIndex and remove it
  * @return null if there is no element with this index */
  public Object remove(int theIndex)
{
   Data theData = getDataElement(theIndex);
   if (theData == null)
      // no element with index theIndex
      return null;

   // there is an element with index theIndex, remove it
   theRemove(theData.key);

   return ((IndexedElement) theData.element).element;
}
<hr class=coderule>
</pre>
<br><br>


Our insert and delete codes penalize successful insertions and
deletions over unsuccessful ones.
Since we would normally expect inserts and deletes to succeed, we may rewrite
the code so as to update <code class=code>leftSize</code> fields on the
first pass assuming that the update is necessary.
In case it turns out that the update was not to be done,
a second pass is made and <code class=code>leftSize</code> values
reset.
<br><br>

The get, insert, and delete methods
have complexity <code class=var>O(h)</code>, where <code class=var>h</code>
is the height of the search tree.  The relevant files are
<code class=code>IndexedBinarySearchTree.*</code>.


</FONT>
</BODY>
</HTML>
