
<HTML>
<HEAD>
<LINK rel="stylesheet" href="../exer.css">
</HEAD>
<BODY>
<H1>
Data Structures, Algorithms, & Applications in Java<BR>
Chapter 15, Exercise 15<BR>
<BR>
</H1>

The max element is found by starting at the root
and making as many right child moves as possible.
The node at which this sequence of moves terminates
has an empty right subtree and so can be deleted by
changing the right child pointer of the parent node to
point to the left child of the node being deleted.
The code is given below.
Its complexity is <code class=var>O(h)</code>
because we spend <code class=code>O(1)</code> time at each level of the tree.


<HR class = coderule>
<pre class = code>
public class BinarySearchTreeWithRemoveMax extends BinarySearchTree
{
   /** @return element with maximum key and remove it
     * @return null if tree is empty */
   public Object removeMax()
   {
      if (root == null)
         // tree is empty
         return null;

      // p will eventually point to node with maximum key
      BinaryTreeNode p = root,    // search pointer
                     pp = null;   // parent of p

      // follow right child pointers to element with maxkey
      while (p.rightChild != null)
      {// move to right child of p
         pp = p;
         p = p.rightChild;
      }

      // save element to be removed
      Object theElement = ((Data) p.element).element; 
   
      // remove node p from the tree, p has at most one child
      if (p == root)
         root = p.leftChild;
      else
         pp.rightChild = p.leftChild;
   
      return theElement;
   }
}
<hr class=coderule>
</pre>




</FONT>
</BODY>
</HTML>
