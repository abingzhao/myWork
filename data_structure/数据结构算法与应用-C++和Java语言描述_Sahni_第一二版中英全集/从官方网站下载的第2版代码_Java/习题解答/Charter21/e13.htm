<HTML>
<HEAD>
<LINK rel="stylesheet" href="../exer.css">
</HEAD>
<BODY>
<H1>
Data Structures, Algorithms, & Applications in Java<BR>
Chapter 21, Exercise 13<BR>
<BR>
</H1>

The back tracking codes for the max
clique and max independent set problems are closely related.
The code is given below.  Changes, other than those to the documentation
and method names, made to the code for the max clique problem are
shown in <font color=red>red</font>.

<HR class = coderule>
<pre class = code>
public class AdjacencyGraphWithMaxIndependentSet extends AdjacencyGraph
{
   // constructors
   public AdjacencyGraphWithMaxIndependentSet(int theVertices)
      {super(theVertices);}

   public AdjacencyGraphWithMaxIndependentSet()
      {this(0);}

   // class data members used by backtracking max independent set
   static int [] currentIndependentSet;
   static int sizeOfCurrentIndependentSet;
   static int sizeOfMaxIndependentSetSoFar;
   static int [] maxIndependentSetSoFar;
   
   /** solve max-independent-set problem using backtracking
     * return size of max independent set
     * param maxIndependentSet set maxIndependentSet[i] = 1
     * iff i is in max independent set */
   public int btMaxIndependentSet(int [] maxIndependentSet)
   {
      // initialize for rIndependentSet
      currentIndependentSet = new int [n + 1];
      sizeOfCurrentIndependentSet = 0;
      sizeOfMaxIndependentSetSoFar = 0;
      maxIndependentSetSoFar = maxIndependentSet;
   
      // find max independent set
      rIndependentSet(1);
      return sizeOfMaxIndependentSetSoFar;
   }
   
   /** recursive backtracking code to compute largest independent set */
   private void rIndependentSet(int currentLevel)
   {
      if (currentLevel &gt; n)
      {// at leaf, found a larger independent set
         // update maxIndependentSetSoFar and sizeOfMaxIndependentSetSoFar
         for (int j = 1; j <= n; j++)
            maxIndependentSetSoFar[j] = currentIndependentSet[j];
         sizeOfMaxIndependentSetSoFar = sizeOfCurrentIndependentSet;
         return;
      }
   
      // not at leaf, see if vertex currentLevel is connected to any vertex
      // in current independent set
      boolean connected = false;
      for (int j = 1; j &lt; currentLevel; j++)
         if (currentIndependentSet[j] == 1 && <font color=red>a[currentLevel][j]</font>)
         {// vertex currentLevel is connected to vertex j
            connected = true;
            break;
         }
   
      if (<font color=red>!connected</font>)
      {// try currentIndependentSet[currentLevel] = 1
         // add vertex currentLevel to independent set
         currentIndependentSet[currentLevel] = 1;
         sizeOfCurrentIndependentSet++;
         rIndependentSet(currentLevel + 1);
         sizeOfCurrentIndependentSet--;
      }
   
      if (sizeOfCurrentIndependentSet + n - currentLevel
                &gt; sizeOfMaxIndependentSetSoFar)
      {// try currentIndependentSet[currentLevel] = 0
         currentIndependentSet[currentLevel] = 0;
         rIndependentSet(currentLevel + 1);
      }
   }
}
<hr class=coderule>
</pre>

</FONT>
</BODY>
</HTML>
