<HTML>
<HEAD>
<LINK rel="stylesheet" href="../exer.css">
</HEAD>
<BODY>
<H1>
Data Structures, Algorithms, & Applications in Java<BR>
Chapter 21, Exercise 7<BR>
<BR>
</H1>

We define a new data member <code class=code>saveToIndex</code>
for the class
<code class=code>RecursiveBTLoading4</code>.
This gives the largest
<code class=code>i</code> for which we have to save the
<code class=code>x[i]</code> value.
Whenever we find a better solution,
<code class=code>saveToIndex</code>
is reset to <code class=code>numberOfContainers</code> indicating that
<code class=code>x[1:numberOfContainers]</code> are to be saved.
When we backup from a node, we first determine if the
<code class=code>x[i]</code> value is to be saved.
If it is to be saved, then the <code class=code>x[i]</code> value
is saved and the value of
<code class=code>saveToIndex</code> is decreased by <code class=code>1</code>.
<br><br>
The new code is given below.  Changes from <code class=code>RecursiveBTLoading3</code>
are shown in <font color=red>red</font>.

<HR class = coderule>
<pre class = code>
public class RecursiveBTLoading4
{
   // class data members
   static int numberOfContainers;
   static int [] weight;
   static int capacity;
   static int weightOfCurrentLoading;
   static int maxWeightSoFar;
   static int remainingWeight;
   static int [] currentLoading;
   static int [] bestLoadingSoFar;
   <font color=red>static int saveToIndex; // incremental saving of
                           // bestLoadingSoFar[1:saveToIndex] yet to be done</font>
   
   
   /** param theWeight array of container weights
     * param theCapacity capacity of ship
     * param bestLoading solution array
     * return weight of max loading */
   public static int maxLoading(int [] theWeight, int theCapacity,
                                int [] bestLoading)
   {
      // set class data members
      numberOfContainers = theWeight.length - 1;
      weight = theWeight;
      capacity = theCapacity;
      weightOfCurrentLoading = 0;
      maxWeightSoFar = 0;
      currentLoading = new int [numberOfContainers + 1];
      bestLoadingSoFar = bestLoading;
      <font color=red>saveToIndex = 0;</font>
   
      // initialize r to sum of all weights
      for (int i = 1; i <= numberOfContainers; i++)
         remainingWeight += weight[i];

      // compute weight of best loading
      rLoad(1);
      return maxWeightSoFar;
   }
   
   /** actual method to find best loading */
   private static void rLoad(int currentLevel)
   {// search from a node at currentLevel
      if (currentLevel &gt; numberOfContainers)
      {// at a leaf, need to save all values
         <font color=red>saveToIndex = numberOfContainers;</font>
         maxWeightSoFar = weightOfCurrentLoading;
         return;
      }

      // not at a leaf, check subtrees
      remainingWeight -= weight[currentLevel];
      if (weightOfCurrentLoading + weight[currentLevel] <= capacity)
      {// try left subtree
         currentLoading[currentLevel] = 1;
         weightOfCurrentLoading += weight[currentLevel];
         rLoad(currentLevel + 1);
         <font color=red>if (saveToIndex == currentLevel)
         {// must save x[saveToIndex]
            bestLoadingSoFar[saveToIndex] = 1;
            saveToIndex--;
         }</font>
         weightOfCurrentLoading -= weight[currentLevel];
      }
      if (weightOfCurrentLoading + remainingWeight &gt; maxWeightSoFar)
      {
         currentLoading[currentLevel] = 0; // try right subtree
         rLoad(currentLevel + 1);
         <font color=red>if (saveToIndex == currentLevel)
         {// must save x[saveToIndex]
            bestLoadingSoFar[saveToIndex] = 0;
            saveToIndex--;
         }</font>
      }
      remainingWeight += weight[currentLevel];
   }
}
<hr class=coderule>
</pre>

</FONT>
</BODY>
</HTML>
