<HTML>
<HEAD>
<LINK rel="stylesheet" href="../exer.css">
</HEAD>
<BODY>
<H1>
Data Structures, Algorithms, & Applications in Java<BR>
Chapter 21, Exercise 9<BR>
<BR>
</H1>
We shall employ strategy 2 so that the complexity of the
code remains <code class=var>O(2<sup>n</sup>)</code>.
We define a new data member <code class=code>iMax</code>
which gives the largest
<code class=code>i</code> for which we have to save the
<code class=code>x[i]</code> value.
Whenever we find a better solution,
<code class=code>iMax</code>
is reset to <code class=code>n</code> indicating that
<code class=code>x[1:n]</code> are to be saved.
When we backup from a node, we first determine if the
<code class=code>x[i]</code> value is to be saved.
If it is to be saved, then the <code class=code>x[i]</code> value
is saved and the value of
<code class=code>iMax</code> is decreased by <code class=code>1</code>.
<br><br>
Since the objects are reordered by profit densities, it is necessary
for us to record the mapping between objects in the sorted order and
in the original order. For this purpose, we use an additional
array <code class=code>id</code>;
<code class=code>id[i]</code> gives the original index of the
<code class=code>i</code>th object in sorted order.
<br><br>
The new code is given below.  Changes from <code class=code>RecursiveBTKnapsack</code>,
which is the code given in the text,
are shown in <font color=red>red</font>.

<HR class = coderule>
<pre class = code>
public class RecursiveBTKnapsack2
{
   // top-level nested class
   private static class Element implements Comparable
   {
      // data members
      int id;   // object identifier
      double profitDensity;

      // constructor
      private Element(int theID, double theProfitDensity)
      {
         id = theID;
         profitDensity = theProfitDensity;
      }

      public int compareTo(Object x)
      {
         double xpd = ((Element) x).profitDensity;
         if (profitDensity &lt; xpd) return -1;
         if (profitDensity == xpd) return 0;
         return 1;
      }

      public boolean equals(Object x)
         {return profitDensity == ((Element) x).profitDensity;}
   }


   // class data members
   static double capacity;
   static int numberOfObjects;
   static double [] weight;
   static double [] profit;
   static double weightOfCurrentPacking;
   static double profitFromCurrentPacking;
   static double maxProfitSoFar;
   <font color=red>static int [] id;       // original id of object i
   static int [] currentSolution;
   static int [] bestPackingSoFar;    // best solution so far
   static int saveToIndex; // incremental saving of
                           // bestPackingSoFar[1:saveToIndex] yet to be done</font>
   
   /** param theProfit[1:theProfit.length] is array of object profits
     * param theWeight[1:theProfit.length] is array of object weights
     * param theCapacity is knapsack capacity
     <font color=red>* param theBestPacking solution array</font>
     * return profit of best filling */
   public static double knapsack(double [] theProfit, double [] theWeight,
                                 double theCapacity, <font color=red>int [] theBestPacking</font>)
   {
      // set class data members
      capacity = theCapacity;
      numberOfObjects = theProfit.length - 1;
      weightOfCurrentPacking = 0.0;
      profitFromCurrentPacking = 0.0;
      maxProfitSoFar = 0.0;

      // define an Element array for profit densities
      Element [] q  = new Element [numberOfObjects];
   
      // set up densities in q[0:n-1]
      for (int i = 1; i <= numberOfObjects; i++)
         q[i - 1] = new Element(i, theProfit[i] / theWeight[i]);
   
      // sort into increasing density order
      MergeSort.mergeSort(q);
   
      // initialize class members
      profit = new double [numberOfObjects + 1];
      weight = new double [numberOfObjects + 1];
      <font color=red>id = new int [numberOfObjects + 1];</font>
      for (int i = 1; i <= numberOfObjects; i++)
      {// profits and weights in decreasing density order
         profit[i] = theProfit[q[numberOfObjects - i].id];
         weight[i] = theWeight[q[numberOfObjects - i].id];
         <font color=red>id[i] = q[numberOfObjects - i].id;</font>
      }
      <font color=red>currentSolution = new int [numberOfObjects + 1];
      bestPackingSoFar = theBestPacking;
      saveToIndex = 0;</font>

      rKnap(1);  // compute max profit

      <font color=red>if (maxProfitSoFar == 0.0)
         // no object fits
         for (int i = 1; i <= numberOfObjects; i++)
            theBestPacking[i] = 0;</font>

      return maxProfitSoFar;
   }
      
   /** actual method to find value of best filling */
   private static void rKnap(int currentLevel)
   {// search from a node at currentLevel
      if (currentLevel &gt; numberOfObjects)
      {// at a leaf, <font color=red>need to save all values
         saveToIndex = numberOfObjects;</font>
         maxProfitSoFar = profitFromCurrentPacking;
         return;
      }

      // not at a leaf, check subtrees
      if (weightOfCurrentPacking + weight[currentLevel] <= capacity)
      {// try left subtree
         <font color=red>currentSolution[currentLevel] = 1;</font>
         weightOfCurrentPacking += weight[currentLevel];
         profitFromCurrentPacking += profit[currentLevel];
         rKnap(currentLevel + 1);
         <font color=red>if (saveToIndex == currentLevel)
         {// must save currentSolution[currentLevel]
            bestPackingSoFar[id[currentLevel]] = 1;
            saveToIndex--;
         }</font>
         weightOfCurrentPacking -= weight[currentLevel];
         profitFromCurrentPacking -= profit[currentLevel];
      }
      if (profitBound(currentLevel + 1) &gt; maxProfitSoFar)
      {// try right subtree
         <font color=red>currentSolution[currentLevel] = 0;</font>
         rKnap(currentLevel + 1);
         <font color=red>if (saveToIndex == currentLevel)
         {// must save currentSolution[currentLevel]
            bestPackingSoFar[id[currentLevel]] = 0;
            saveToIndex--;
         }</font>
      }
   }
   
   /** bounding function
     * return upper bound on value of best leaf in subtree */
   private static double profitBound(int currentLevel)
   {
      double remainingCapacity = capacity - weightOfCurrentPacking;
      double profitBound = profitFromCurrentPacking;
      // fill remaining capacity in order of profit density
      while (currentLevel <= numberOfObjects &&
             weight[currentLevel] <= remainingCapacity)
      {
         remainingCapacity -= weight[currentLevel];
         profitBound += profit[currentLevel];
         currentLevel++;
      }
   
      // take fraction of next object
      if (currentLevel <= numberOfObjects)
         profitBound += profit[currentLevel] / weight[currentLevel]
                           * remainingCapacity;
      return profitBound;
   }
}
<hr class=coderule>
</pre>

</FONT>
</BODY>
</HTML>
