
<HTML>
<HEAD>
<LINK rel="stylesheet" href="../exer.css">
</HEAD>
<BODY>
<H1>Data Structures & Algorithms</H1>

<H2>Exam 3, Sample 2</H2>
<H2>2 Hours</H2>
<BR>
</H1>

<strong>Notes:</strong>
<ol>
<li>
Points allocated to each part are shown in square brackets.
Answers will be graded on correctness as well as efficiency,
elegance, and other measures of quality.
<li>
Make sure you understand the problem before attempting to answer it.
<li>
Write partial answers when you cannot figure out a complete solution.
</ol>

<OL>
<LI>
[10]
You are to write a method <code class=code>boolean twoColor(int i, int [] label)</code>.
The invocation <code class=code>g.twoColor(theI, theLabel)</code> labels all
of the vertices in the component that contains vertex <code class=code>theI</code>.
Some of these vertices are labeled <code class=code>1</code>, and the remaining
vertices of the component are labeled <code class=code>2</code>.
The labeling is done in such a way that for every edge <code class=code>(i,j)</code>
in <code class=code>g</code>, vertices <code class=code>i</code> and <code class=code>j</code>
have different labels.
You may assume that, initially,
<code class=code>theLabel[j] = 0</code> for all vertices
<code class=code>j</code> that are in the same component as vertex
<code class=code>i</code>.
The method returns <code class=code>false</code> iff it is not possible to
do the labeling as stated.
An example component with <code class=code>theI = 11</code>
and labeled as described above is shown below (only vertices
in the component are shown, the remaining vertices of the graph are omitted).
<center>
<font color=blue>
<img src=q99fig.gif>
</font>
</center>
<dl compact>
<dt> (a)
<dd>
[8]
Write Java code for the method <code class=code>twoColor</code>.
Note that the labeling may be done using either a depth first or
breadth first search beginning at vertex <code class=code>theI</code>.
If you wish to use recursion, you will need to write an additional
private method. If you need to use a stack or a queue, use
either <code class=code>ArrayStack</code> or <code class=code>ArrayQueue</code>.
Use iterators to move around the graph; use the method
<code class=code>vertex()</code> to determine the number of vertices
in <code class=code>g</code>.
<dt> (b)
<dd>
[2]
What is the complexity of your labeling method as a function of the
number of vertices and edges in the component being labeled?
Provide this complexity under the assumption that adjacency lists are used.
Explain your analysis (a few lines only).
</dl>
<br>
<LI>
[10]
You are given <code class=code>n</code> jobs. Each job has a length, release
time, and deadline associated with it. All job lengths and deadlines
are <code class=code>&gt; 0</code>, and all release times
are <code class=code>&gt;= 0</code>. To successfully complete a job,
the processing of this job must begin at or after its release time,
the processing must complete by its deadline, and the job must be
processed for an amount of time that equals its length. Only one processor
is available to process jobs. Therefore, at any time at most one
job may be worked on.
Suppose there is a job whose length is <code class=code>6</code>,
release time is <code class=code>3</code>, and deadline is
<code class=code>14</code>. The processing of this job may commence at
any time <code class=code>t</code>,
<code class=code>t &gt= 3</code>. In a successful processing, the
processing must finish by time <code class=code>14</code> and the
processing duration must be <code class=code>6</code>.
So, if we start processing this job at time <code class=code>t</code>,
<code class=code>3 &lt= t &lt= 8</code>, we will finish at
<code class=code>t + 6 &lt= 14</code> and have a successful processing
of the job. While this job is being worked on (i.e., from
time <code class=code>t</code> to <code class=code>t + 6</code>),
we cannot work on any other job; the processing of another job
may commence as early as <code class=code>t + 6</code>.
<dl compact>
<dt> (a)
<dd>
[7]
Give a greedy algorithm that attempts to select the maximum number of jobs
that may be successfully processed by a single processor.
Pseudocode (a precise statement of the algorithm
using a combination of English and programming language constructs)
will suffice.
<dt> (b)
<dd>
[3]
Does your algorithm
guarantee to select the maximum number of jobs
that can be successfully processed
by a single processor?
Prove your answer.
</dl>
<br>
<LI>
[18]
A
machine has <code class=code>n</code> components.
For each component, there are two suppliers.  The weight of component
<code class=code>i</var> from supplier <code class=code>j</var> is
<code class=code>W(i,j)</var>, and its cost is <code class=code>C(i,j)</var>,
<code class=code>1 &lt= j &lt= 2</var>.  You may assume that
<code class=code>W(i,1) &gt; W(i,2)</var> and <code class=code>C(i,1) &lt; C(i,2)</var>
for all <code class=code>i</code>.
<br><br>
Assume that the <code class=code>C</code>s
and <code class=code>c</code>,
are positive integers.
The cost of the machine is
the sum of the
component costs, and its weight is the sum of the
component weights.
<br><br>
We wish to use dynamic programming to determine the
supplier for each component so as to build the lightest machine with
cost no more than <code class=code>c</code>.
<dl compact>
<dt>(a)
<dd>
[5]
Let <code class=code>w(i,j)</var> be the weight of the lightest machine
composed of components <code class=code>i</var> through <code class=code>n</var>
that costs no more than <code class=code>j</var>.
Obtain the dynamic programming recurrence for <code class=code>w(i,j)</code>,
<code class=code>1 &lt= i &lt= n</code> and
<code class=code>0 &lt= j &lt= c</code>.
<dt> (b)
<dd>
[10]
Obtain an <code class=code>O(cn)</code> time algorithm to
compute <code class=code>w(i,j)</code>, <code class=code>1 <= i <= n</code>, <code class=code>0 <= j <= c</code>.
Pseudocode
will suffice.
<dt> (c)
<dd>
[3]
Describe how you can use the <code class=code>w(i,j)</code> values computed
in (b) to determine the suppliers for each component so that we get the
lightest machine whose cost is at most
<code class=code>c</code>. (I.e., describe how the traceback works.)
</dl>
<br>
<LI>
[8]
Let <code class=code>G</code> be an undirected graph.  We are interested
in determining
the largest subset <code class=code>S</code> of vertices of <code class=code>G</code>
so that <code class=code>G</code> has no edge that connects two
vertices
of <code class=code>S</code> (i.e., if <code class=code>u</code>
and <code class=code>v</code> are in <code class=code>S</code>,
then <code class=code>(u,v)</code> is not an edge of
<code class=code>G</code>).
<dl compact>
<dt> (a)
<dd>
[2]
Obtain a formulation for the solution space for this problem.
Your formulation must correspond either to the subset (fixed or
variable tuple size) or permutation space model.  State which
one you are using.
<dt> (b)
<dd>
[2]
List all members of your solution space for a graph with 3 vertices.
<dt> (c)
<dd>
[2]
Draw a tree organization for your space.  Label all nodes and/or
branches.
<dt> (d)
<dd>
[2]
Number the nodes in your tree organization in the order
in which they are first reached during a backtracking procedure
in which the bounding functions fail to curb any node expansions.
</dl>

<center>
<A href="s2.htm">Solutions</A>

</html>
