

<HTML>
<HEAD>
<LINK rel="stylesheet" href="../exer.css">
</HEAD>
<BODY>
<H2>Exam 2</H2>
<H2>Sample 2, 50 Minutes</H2>
<H2>Solutions</H2>
<BR>
</H1>
<ol>
<li>
<dl compact>
<dt>(a)
<dd>
To perform the operation, we can do a level-order
traversal of the binary tree.  The last element visited in this
order is the deepest element.
During the visit step, we
simply record the element visited in a variable
<code class=code>last</code>.  Upon termination of the
traversal, this variable contains the deepest element.
The code is given below.
The relevant files are <code class=var>ebinary.*</code>.
</dl>
<pre class=code>
<hr class=coderule>
template &lt;class T&gt;
T BinaryTree&lt;T&gt;::DeepestElement()
{// Return the deepest element in the tree.
 // Throw BadInput exception is the tree is empty.
   if (!root) // no deepest element
      throw BadInput();

   // do a level-order traversal keeping track of
   // the most recently seen element
   LinkedQueue&lt;BinaryTreeNode&lt;T&gt;*&gt; Q;
   BinaryTreeNode&lt;T&gt; *t = root;
   T last;  // last element encountered
   while (t) {
      last = t-&gt;data;
      if (t-&gt;LeftChild) Q.Add(t-&gt;LeftChild);
      if (t-&gt;RightChild) Q.Add(t-&gt;RightChild);
      try {Q.Delete(t);}
      catch (OutOfBounds) {return last;}
      }
}
<hr class=coderule>
</pre>
<dl compact>
<dt>(b)
<dd>
Each node of the binary tree is visited once and a constant
amount of work is done during each visit.  If the traversal
is successful, the complexity
is Theta(<code class=var>n</code>), where <code class=var>n</code>
is the number of nodes in the binary tree.
</dl>
<br><br>
<br><br>
<li>
<dl compact>
<dt>(a)
<dd>
The code for <code class=var>ChangeMin</code> is very
similar to that for
<code class=var>DeleteMin</code>.
The code is given below and in
the files <code class=var>minheap4.*</code>.
</dl>
<pre class=code>
<hr class=coderule>
template&lt;class T&gt;
void MinHeap&lt;T&gt;::Initialize(T a[], int size, int ArraySize)
{// Initialize min heap to array a.
   delete [] heap;
   heap = a;
   CurrentSize = size;
   MaxSize = ArraySize;

   // make into a min heap
   for (int i = CurrentSize/2; i &gt;= 1; i--) {
      T y = heap[i]; // root of subtree

      // find place to put y
      int c = 2*i; // parent of c is target
                   // location for y
      while (c &lt;= CurrentSize) {
         // make c point to smaller sibling
         if (c &lt; CurrentSize &amp;&amp;
             heap[c] &gt; heap[c+1]) c++;

         // can we put y in heap[c/2]?
         if (y &lt;= heap[c]) break;  // yes

         // no
         heap[c/2] = heap[c]; // move heap[c] up
         c *= 2;              // move c down a level
         }
      heap[c/2] = y;
      }
}
<hr class=coderule>
</pre>
<dl compact>
<dt>(b)
<dd>
Since a heap is a complete binary tree, the height of a min heap
that has <code class=var>CurrentSize</code> =
<code class=var>n</code> elements is
Theta(<code class=var>log n</code>).  The change min algorithm spends constant
time at a level and goes through at most as many levels as the
height of the min heap.  So the complexity is
O(<code class=var>log n</code>).
</dl>
<br>
<li>
<dl compact>
<dt> (a)
<dd>
Since
<em class=var>
S <SUB>n</sub> = 1 + alpha/2 &lt;= 7, 
alpha &lt;= 12</em><br>
Also, since
<em class=var>
U <SUB>n</sub> = (1 + alpha)/2 &lt;= 12,
alpha &lt;= 23</em>.<br>
So <em class=var>alpha &lt;= min{12, 23} = 12</em>.<br>
Hence <em class=var>n/b = alpha &lt;= 12</em> and so
<em class=var>b &gt;= ceil(n/12) = ceil(81/12) = 7.<br><br></em>

When division is used, the number of buckets equals the
divisor <em class=var>D</em>.  So
<em class=var>D</em> &gt;= 7.  Also
since <em class=var>D</em> should be a prime number
or should have no prime divisors
less than 20, we choose <em class = var>D</em> = 7, which is a prime number.
<br><br>

<dt> (b)
<dd>
This is Lemma 8.1 in the book.  See the proof of this lemma.

<dt> (c)
<dd>
Examine the preorder output from left to right.  In this order,
the first element <code class=var>A</code>
is the root of the binary tree.
Also <code class=var>A</code> comes between the left and right subtree in
inorder.  So the left subtree is empy
and <code class=var>BCDEFGHIJ</code> is the inorder output of the
right subtree.
The next element in preorder
<code class=var>D</code> is the root of the left subtree
unless the left subtree is empty (in which case it is the root
of the right subtree).  Using this information
and what we have already learnt from the inorder sequence, we
see that <code class=var>D</code> is the root of the right subtree
and <code class=var>BC</code> are in the left subtree of
<code class=var>D</code> and <code class=var>EFGHIJ</code> are
in its right subtree.
Proceeding in this way we can construct the entire binary tree.
The unique binary tree from which the given inorder and preorder outputs
came is:
<br><br>
<pre class=figure>
                       A
                        \
                           D
                        /    \
                      B        J
                       \      /   
                         C   G      
                            / \       
                           F   H
                          /      \           
                         E         I
             
              
</pre>
</dl>
</ol>
<CENTER><a href="q97b.mhtml">BACK</a></CENTER>
<!--crfooter.mhtml-->

<CENTER>
<IMG SRC="/catalogs/img/space.gif" WIDTH="10" HEIGHT="20" BORDER="0">
<P>
<font class="smalltext">
<A HREF="/catalogs/cust_serv/feedback.mhtml" TARGET="_top" CLASS="link">
<font face="verdana, arial, helvetica" size="1">feedback form</font></A> |   
<A HREF="/catalogs/cust_serv/permissions.mhtml" TARGET="_top" CLASS="link">
<font face="verdana, arial, helvetica" size="1">permissions</font></A> |   
<A HREF="/catalogs/international" TARGET="_top" CLASS="link">
<font face="verdana, arial, helvetica" size="1">international</font></A> |
<A HREF="/catalogs/rep/" TARGET="_top" CLASS="link">
<font face="verdana, arial, helvetica" size="1">locate your campus rep</font></A> |  
<A HREF="/catalogs/cust_serv/review1.mhtml" TARGET="_top" CLASS="link">
<font face="verdana, arial, helvetica" size="1">request a review copy</font></A>
<BR>
<BR>
<A HREF="/catalogs/solutions/" TARGET="_top" CLASS="link">
<font face="verdana, arial, helvetica" size="1">digital solutions</font></A> | 
<A HREF="/catalogs/work/" TARGET="_top" CLASS="link">
<font face="verdana, arial, helvetica" size="1">publish with us</font></A> | 
<A HREF="/catalogs/cust_serv/" TARGET="_top" CLASS="link">
<font face="verdana, arial, helvetica" size="1">customer service</font></A> |   
<A HREF="/catalogs/index.mhtml" TARGET="_top" CLASS="link">
<font face="verdana, arial, helvetica" size="1">mhhe home</font></A>
<P>
<HR>
<P>
<font face="verdana, arial, helvetica" size="1">
Copyright &copy;2001 The McGraw-Hill Companies.<BR>
Any use is subject to the <A HREF="http://www.mcgraw-hill.com/copyrttm.htm" CLASS="link" TARGET="_new">
<font face="verdana, arial, helvetica" size="1">Terms of Use</font></A> and <A HREF="/catalogs/privacy_notice.mhtml" 
CLASS="link" TARGET="_new"><font face="verdana, arial, helvetica" size="1">Privacy Policy</font></A>.<BR>
McGraw-Hill Higher Education is one of the many fine businesses of the 
<A HREF="http://www.mcgraw-hill.com" CLASS="link" TARGET="_new"><font face="verdana, arial, helvetica" size="1">
The McGraw-Hill Companies</font></A>.
</font>
</font>

</CENTER>


